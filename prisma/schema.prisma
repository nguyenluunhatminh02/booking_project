// ===========================
// Prisma Schema - Booking App
// ===========================

// ---------- Generators / Datasource ----------
generator client {
  provider          = "prisma-client-js"
  previewFeatures   = ["postgresqlExtensions"]
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  // Bật citext để dùng @db.Citext cho email/promo code…
  extensions = [citext(map: "citext")]
}

// ---------- Enums ----------
enum ACLEffect { 
  ALLOW 
  DENY 
}

enum PromotionType { 
  PERCENT 
  FIXED 
}

enum ReviewStatus { 
  ACTIVE 
  HIDDEN 
  DELETED 
}

enum RiskLevel { 
  LOW 
  MEDIUM 
  HIGH 
} // dùng cho FraudAssessment.level

enum FraudDecision { 
  PENDING 
  APPROVED 
  REJECTED 
  AUTO_DECLINED 
}

enum SessionRevokeReason { 
  USER_LOGOUT 
  ADMIN_FORCE 
  SECURITY_REUSE 
  EXPIRED 
  OTHER
 }

enum SecurityEventType { 
  LOGIN_SUCCESS 
  LOGIN_FAILED 
  TOKEN_REVOKE 
  REFRESH_REUSE 
}

enum UserTokenType { 
  EMAIL_VERIFY 
  PASSWORD_RESET 
  DEVICE_APPROVAL 
}

enum MalwareScanStatus {
  PENDING
  CLEAN
  INFECTED
  ERROR
}


enum BookingStatus { 
  HOLD 
  PAID 
  CANCELLED 
  REFUNDED 
  CONFIRMED 
  REVIEW 
}

/// Lịch sử sử dụng promotion (giúp chống race & hoàn trả)
enum RedemptionStatus { 
  RESERVED 
  APPLIED 
  RELEASED 
}

enum IdemStatus { 
  IN_PROGRESS 
  COMPLETED 
  FAILED 
}

// ---------- Idempotency ----------
model Idempotency {
  id           String     @id @default(uuid())
  userId       String?
  endpoint     String      // ví dụ: "POST /bookings/hold"
  key          String      // từ header: Idempotency-Key
  requestHash  String      // sha256(payload quan trọng)
  status       IdemStatus  @default(IN_PROGRESS)
  resourceId   String?     // bookingId / paymentId...
  response     Json?
  error        Json?
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  expiresAt    DateTime

  @@unique([userId, endpoint, key]) // scope theo user + endpoint + key
  @@index([endpoint, createdAt])
  @@index([expiresAt])
}

// ---------- Core: Users & Sessions ----------
model User {
  id            String   @id @default(uuid())
  email         String   @unique @db.Citext
  password      String
  accessVersion Int      @default(1)
  lockedUntil   DateTime?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // relations
  sessions        UserSession[]
  roles           UserRole[]
  securityEvents  SecurityEvent[]
  auditLogs       AuditLog[]
  properties      Property[]       @relation("HostProperties")
  bookings        Booking[]        @relation("CustomerBookings")
  tokens          UserToken[]

  // others
  ResourceACL     ResourceACL[]
  UserMfa         UserMfa[]
  BackupCode      BackupCode[]
  FraudAssessment FraudAssessment[]
  reviewsAuthored Review[]         @relation("ReviewAuthor") // <— đặt tên rõ ràng

  notiPreference NotiPreference[]
  notification Notification[]
  conversationParticipant ConversationParticipant[]
  message Message[]
  blocker UserBlock[] @relation("Blocker")
  blockee UserBlock[] @relation("Blockee")
  @@map("users")
}

model UserSession {
  id              String   @id @default(uuid())
  userId          String
  deviceId        String?
  refreshHash     String
  tokenVersion    Int      @default(0)
  accessSv        Int      @default(1)
  expiresAt       DateTime
  revokedAt       DateTime?
  revokedReason   SessionRevokeReason?

  // observability / forensics
  ip              String?  @db.Inet
  userAgent       String?

  deviceFp        String?
  approved        Boolean   @default(true)

  lastUsedAt      DateTime?
  rotatedAt       DateTime?
  reusedAt        DateTime?

  // rotate grace window
  prevRefreshHash String?
  prevExpiresAt   DateTime?

  createdAt       DateTime @default(now())

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  securityEvents  SecurityEvent[]

  @@index([userId])
  @@index([expiresAt])
  @@index([userId, revokedAt])
  @@map("user_sessions")
}

// ---------- RBAC ----------
model Role {
  id        String   @id @default(uuid())
  name      String   @unique
  desc      String?
  isSystem  Boolean  @default(false)
  createdAt DateTime @default(now())

  rolePerms RolePermission[]
  userRoles UserRole[]

  @@map("roles")
}

model Permission {
  id        String   @id @default(uuid())
  action    String
  subject   String
  desc      String?
  createdAt DateTime @default(now())

  rolePerms RolePermission[]

  @@unique([action, subject], name: "action_subject")
  @@map("permissions")
}

model RolePermission {
  roleId       String
  permissionId String
  createdAt    DateTime @default(now())

  role        Role        @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission  Permission  @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
  @@map("role_permissions")
}

model UserRole {
  id          String    @id @default(uuid())
  userId      String
  roleId      String
  effectiveAt DateTime?
  expiresAt   DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId], name: "user_role_unique")
  @@map("user_roles")
}

// ---------- Instance-level ACL ----------
model ResourceACL {
  id           String    @id @default(uuid())
  userId       String
  resourceType String
  resourceId   String
  action       String
  effect       ACLEffect @default(ALLOW)
  createdAt    DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, resourceType, resourceId, action], name: "user_resource_action_unique")
  @@index([resourceType, resourceId])
  @@map("resource_acl")
}

// ---------- Audit & Security ----------
model SecurityEvent {
  id        String            @id @default(uuid())
  userId    String?
  sessionId String?
  type      SecurityEventType
  ip        String?  @db.Inet
  userAgent String?
  deviceFp  String?
  meta      Json?
  createdAt DateTime          @default(now())

  user    User?        @relation(fields: [userId], references: [id], onDelete: SetNull)
  session UserSession? @relation(fields: [sessionId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
  @@index([userId, type, createdAt])
  @@index([sessionId])
  @@map("security_events")
}

model AuditLog {
  id        String   @id @default(uuid())
  actorId   String?
  action    String
  entity    String
  entityId  String?
  meta      Json?
  createdAt DateTime @default(now())

  actor User? @relation(fields: [actorId], references: [id], onDelete: SetNull)

  @@index([entity, entityId, createdAt])
  @@map("audit_logs")
}

// ---------- Feature Flags ----------
model FeatureFlag {
  key       String   @id
  enabled   Boolean  @default(false)
  payload   Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ---------- Domain ----------
model Property {
  id          String    @id @default(uuid())
  hostId      String
  title       String
  address     String
  description String?

  // Geo
  lat         Float?    @db.DoublePrecision
  lng         Float?    @db.DoublePrecision

  // Amenities JSONB
  amenities   Json?     @default(dbgenerated("'{}'::jsonb"))

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  host        User      @relation("HostProperties", fields: [hostId], references: [id], onDelete: Cascade)
  availability AvailabilityDay[]
  bookings    Booking[]
  reviews     Review[]

  // Rating aggregates
  ratingCount     Int       @default(0)
  ratingAvg       Float     @default(0)
  ratingUpdatedAt DateTime?

  mediaLinks   PropertyFile[]
  @@index([hostId])
  Conversation Conversation[]
}

model AvailabilityDay {
  id          String    @id @default(uuid())
  propertyId  String
  date        DateTime  // ngày (UTC 00:00)
  price       Int
  remaining   Int
  isBlocked   Boolean   @default(false)

  property    Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@unique([propertyId, date])
  @@index([propertyId, date])
}

model Booking {
  id                 String        @id @default(uuid())
  propertyId         String
  customerId         String
  checkIn            DateTime
  checkOut           DateTime
  status             BookingStatus @default(HOLD)
  totalPrice         Int
  promoCode          String?       @db.Citext
  holdExpiresAt      DateTime?
  discountAmount     Int           @default(0)   // final = totalPrice - discountAmount

  // Promotion áp dụng (snapshot liên kết)
  appliedPromotionId  String?
  appliedPromotion    Promotion?   @relation(fields: [appliedPromotionId], references: [id])

  // (Tuỳ chọn) Chính sách huỷ/hoàn
  cancelPolicyId       String?
  cancelPolicy         CancelPolicy? @relation(fields: [cancelPolicyId], references: [id])
  cancelPolicySnapshot Json?

  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt

  property           Property      @relation(fields: [propertyId], references: [id], onDelete: Restrict)
  customer           User          @relation("CustomerBookings", fields: [customerId], references: [id], onDelete: Restrict)
  payment            Payment?

  // NEW: deadline cho reviewer (tuỳ chọn)
  reviewDeadlineAt   DateTime?

  // REVIEW: back relation 1–1
  review             Review?

  // Fraud
  fraudAssessment    FraudAssessment?

  PromotionRedemption  PromotionRedemption[]

  @@index([propertyId])
  @@index([customerId])
  @@index([checkIn, checkOut])
  @@index([propertyId, status])
  @@index([status, holdExpiresAt])      // phục vụ saga expire
  @@index([status, reviewDeadlineAt])   // SLA review (tuỳ chọn)
  @@index([propertyId, customerId, checkOut]) // phục vụ kiểm tra "đã ở xong"
}

model FraudAssessment {
  id          String        @id @default(uuid())
  bookingId   String        @unique
  userId      String
  score       Int
  level       RiskLevel
  decision    FraudDecision @default(PENDING)
  reasons     Json
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  // Audit
  reviewedById String?
  reviewedAt   DateTime?
  reviewedNote String?

  reviewer     User?        @relation(fields: [reviewedById], references: [id], onDelete: SetNull)
  booking      Booking      @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([level, decision])
}

model PromotionRedemption {
  id           String           @id @default(uuid())
  promotionId  String
  bookingId    String           @unique // 1 booking ↔ 1 redemption
  userId       String

  code         String           // snapshot code lúc dùng
  amount       Int
  status       RedemptionStatus @default(RESERVED)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  promotion    Promotion @relation(fields: [promotionId], references: [id], onDelete: Restrict)
  booking      Booking   @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@index([promotionId, status])
  @@index([userId])
  // @@unique([promotionId, userId]) // nếu muốn giới hạn 1 user / 1 promo
}

// ---------- Files & Property Media ----------
model File {
  id           String    @id @default(uuid())
  key          String    @unique
  url          String
  bytes        Int?
  width        Int?
  height       Int?
  contentType  String?
  checksum     String?
  tags         String[]
  createdById  String?

   // NEW: trạng thái quét virus
  malwareStatus    MalwareScanStatus @default(PENDING)
  malwareSignature String?
  scannedAt        DateTime?

  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt


  propertyLinks PropertyFile[]
  variants      FileVariant[]

  @@index([createdById, createdAt])
  MessageAttachment MessageAttachment[]
}

model PropertyFile {
  id          String    @id @default(uuid())
  propertyId  String
  fileId      String
  type        MediaType
  sortOrder   Int       @default(0)
  isCover     Boolean   @default(false)
  createdAt   DateTime  @default(now())

  property    Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  file        File      @relation(fields: [fileId], references: [id], onDelete: Cascade)

  @@unique([propertyId, fileId])
  @@index([propertyId, sortOrder])
  @@index([propertyId, isCover])
}

model FileVariant {
  id           String   @id @default(uuid())
  fileId       String
  kind         String
  key          String
  url          String
  width        Int?
  height       Int?
  bytes        Int?
  contentType  String?
  createdAt    DateTime @default(now())

  file         File     @relation(fields: [fileId], references: [id], onDelete: Cascade)

  @@unique([fileId, kind])
  @@index([fileId])
}

model Promotion {
  id          String         @id @default(uuid())
  code        String         @db.Citext @unique
  type        PromotionType
  value       Int            // percent: 5..100; fixed: VND
  validFrom   DateTime?
  validTo     DateTime?
  minNights   Int?
  minTotal    Int?
  usageLimit  Int?
  usedCount   Int            @default(0)
  isActive    Boolean        @default(true)

  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  redemptions PromotionRedemption[]
  bookings    Booking[]

  @@index([isActive, validFrom, validTo])
}

// ---------- Cancel Policy (pluggable) ----------
model CancelPolicy {
  id           String   @id @default(uuid())
  name         String
  isActive     Boolean  @default(true)
  // Mảng rule: [{beforeDays:int, refundPercent:int}, ...]
  rules        Json
  // Tuỳ chọn tính theo giờ địa phương chính xác
  checkInHour  Int?
  cutoffHour   Int?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  bookings     Booking[]
}

// ---------- One-time Tokens / MFA ----------
model UserToken {
  id        String        @id @default(uuid())
  userId    String?
  type      UserTokenType
  tokenHash String
  meta      Json?
  createdAt DateTime      @default(now())
  expiresAt DateTime
  usedAt    DateTime?
  usedByIp  String? @db.Inet

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([type, expiresAt])
  @@index([userId, type, createdAt])
  @@map("user_tokens")
}

model UserMfa {
  id                String   @id @default(uuid())
  userId            String   @unique
  totpSecret        String
  enabled           Boolean  @default(false)
  verifiedAt        DateTime?
  verifyAttempts    Int      @default(0)
  lastVerifyAt      DateTime?
  recoveryKeyHash   String?
  recoveryKeyUsedAt DateTime?
  createdAt         DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_mfa")
}

model BackupCode {
  id        String   @id @default(uuid())
  userId    String
  codeHash  String
  usedAt    DateTime?

  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, usedAt])
  @@map("backup_codes")
}

// ---------- Outbox (Debezium style) & Processed Event ----------
model Outbox {
  id        String   @id @default(uuid())
  eventKey  String?
  topic     String
  payload   Json
  createdAt DateTime @default(now())

  @@index([topic, createdAt])
}

model ProcessedEvent {
  id        String   @id        // Debezium message key/offset hoặc header id
  handledAt DateTime @default(now())
}

// ---------- Reviews ----------
model Review {
  id         String       @id @default(uuid())
  bookingId  String       @unique            // 1 booking = 1 review
  propertyId String
  authorId   String
  rating     Int
  body       String?
  status     ReviewStatus @default(ACTIVE)
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  booking    Booking      @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  property   Property     @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  author     User         @relation("ReviewAuthor", fields: [authorId], references: [id], onDelete: Cascade)

  @@index([propertyId, status, createdAt, id]) // list theo property, lọc status, keyset mượt
  @@index([authorId, createdAt])
}


// ============ Payments ============
enum PaymentProvider {
  MOCK
  STRIPE
  VNPAY
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
  CANCELED
}

enum RefundStatus {
  PENDING
  SUCCEEDED
  FAILED
}

model Payment {
  id         String          @id @default(uuid())
  bookingId  String          @unique
  provider   PaymentProvider
  amount     Int
  currency   String          @default("VND")
  status     PaymentStatus   @default(PENDING)
  intentId   String?
  chargeId   String?
  metadata   Json?
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt

  booking    Booking         @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  refunds    Refund[]

  @@index([provider, chargeId])
  // NOTE: KHÔNG dùng @@unique([provider, intentId]) ở đây để chuyển sang partial unique index (SQL) bên dưới
}

model Refund {
  id               String        @id @default(uuid())
  paymentId        String
  amount           Int
  status           RefundStatus  @default(PENDING)
  providerRefundId String?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  payment          Payment       @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@index([paymentId])
}

model ProcessedWebhook {
  id        String           @id         // ví dụ: "STRIPE:evt_123" / "VNPAY:vnpRef:payDate"
  provider  PaymentProvider
  raw       Json?
  at        DateTime         @default(now())

  @@index([provider, at])
}

// ============ Notifications ============
enum NotiChannel {
  INAPP
  EMAIL
  PUSH
  WEBHOOK
}

enum NotiStatus {
  PENDING
  SENT
  FAILED
  CANCELLED
  READ
}

model Notification {
  id           String      @id @default(uuid())
  userId       String
  key          String                      // ví dụ: 'review_reminder', 'booking_updated'
  channel      NotiChannel
  title        String?
  body         String?
  data         Json?
  dedupeKey    String?                     // tránh gửi trùng một sự kiện
  status       NotiStatus   @default(PENDING)
  deliverAfter DateTime?                   // nếu set → scheduler bắn sau thời điểm này
  sentAt       DateTime?
  readAt       DateTime?

  // Lock + retry (safe multi-instance)
  processingAt DateTime?
  attempts     Int         @default(0)
  lastError    String?

  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([status, deliverAfter, channel, processingAt])
  @@index([userId, channel, readAt, createdAt])

  // Postgres cho phép nhiều NULL => chỉ unique khi có dedupeKey
  @@unique([channel, userId, dedupeKey])
}

model NotiPreference {
  id        String   @id @default(uuid())
  userId    String
  key       String                  // theo noti key, ví dụ: 'review_reminder'
  email     Boolean  @default(true)
  push      Boolean  @default(true)
  inapp     Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, key])
}


// ====== (Append) Chat / Inbox schema ======

// Nếu schema của bạn CHƯA có enum này thì thêm (nếu có rồi thì bỏ qua)
enum MediaType {
  IMAGE
  VIDEO
}

enum ConversationType {
  DIRECT
  PROPERTY
}

model Conversation {
  id          String                 @id @default(uuid())
  type        ConversationType
  key         String?                @unique   // ví dụ: "DIRECT:<u1>:<u2>" | "PROPERTY:<propertyId>:<guestId>"
  propertyId  String?
  createdAt   DateTime               @default(now())
  updatedAt   DateTime               @updatedAt

  property    Property?              @relation(fields: [propertyId], references: [id], onDelete: SetNull)
  participants ConversationParticipant[]
  messages    Message[]

  @@index([propertyId])
  @@map("conversations")
}

model ConversationParticipant {
  id             String      @id @default(uuid())
  conversationId String
  userId         String

  role           String?
  archivedAt     DateTime?
  mutedUntil     DateTime?
  pinnedAt       DateTime?
  lastReadAt     DateTime?     // dùng tính unread

  // snapshot hồ sơ người dùng để render nhanh (name/avatar/role…)
  profileSnapshot Json?

  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId, pinnedAt])
  @@index([userId, archivedAt])
  @@index([conversationId, userId, lastReadAt])
  @@map("conversation_participants")
}

model Message {
  id             String        @id @default(uuid())
  conversationId String
  senderId       String
  body           String?                        // media-only OK
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  deletedAt      DateTime?

  conversation   Conversation   @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User           @relation(fields: [senderId], references: [id], onDelete: Cascade)
  attachments    MessageAttachment[]

  @@index([conversationId, createdAt])
  @@index([senderId, createdAt])
  @@index([conversationId, createdAt, senderId])
  @@map("messages")
}

model MessageAttachment {
  id           String     @id @default(uuid())
  messageId    String
  fileId       String
  mediaType    MediaType
  url          String?
  bytes        Int?
  width        Int?
  height       Int?
  contentType  String?
  createdAt    DateTime   @default(now())

  message      Message    @relation(fields: [messageId], references: [id], onDelete: Cascade)
  file         File       @relation(fields: [fileId], references: [id], onDelete: Restrict)

  @@index([messageId])
  @@index([fileId])
  @@map("message_attachments")
}

// ===== Block list (1 chiều) =====
model UserBlock {
  id             String   @id @default(uuid())
  userId         String   // blocker
  blockedUserId  String   // blockee
  createdAt      DateTime @default(now())

  blocker   User @relation("Blocker", fields: [userId], references: [id], onDelete: Cascade)
  blockee   User @relation("Blockee", fields: [blockedUserId], references: [id], onDelete: Cascade)

  @@unique([userId, blockedUserId])
  @@index([blockedUserId])
  @@map("user_blocks")
}
